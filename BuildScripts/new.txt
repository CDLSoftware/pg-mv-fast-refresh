CREATE OR REPLACE FUNCTION pgrs_mview.mv$outerJoinDeleteStatement(
	pConst          IN      mv$allConstants,
	pTableNames 	IN		TEXT,
	pTableAlias 	IN		TEXT,
	pViewnName		IN      TEXT,
	pRowidArray		IN      TEXT[],
	pWhereClause	IN		TEXT,
	pTableName		IN		TEXT)
    RETURNS text
AS $BODY$
/* ---------------------------------------------------------------------------------------------------------------------------------
Routine Name: mv$outerJoinDeleteStatement
Author:       David Day
Date:         23/02/2021
------------------------------------------------------------------------------------------------------------------------------------
Revision History    Push Down List
------------------------------------------------------------------------------------------------------------------------------------
Date        | Name          | Description
------------+---------------+-------------------------------------------------------------------------------------------------------
            |               |
23/02/2021  | D Day      	| Initial version
------------+---------------+-------------------------------------------------------------------------------------------------------
Description:    Function to replace the alias driven outer join conditions to inner join in the from tables join sql
				regular expression pattern.

Arguments:      IN      pTableNames             
                IN      pTableAlias              
Returns:                TEXT

************************************************************************************************************************************
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved. SPDX-License-Identifier: MIT-0
***********************************************************************************************************************************/
DECLARE	

	tJoinTableInfoFound		CHAR := 'N';
	tOtherTableFound		CHAR := 'N';
	
	tLeftJoinConditions		TEXT;
	tRightJoinConditions	TEXT;
	
	tTableName				TEXT := pTableName;
	
	iLeftJoinCnt 			INTEGER := 0;	
	iRightJoinCnt 			INTEGER := 0;	
	
	iLoopLeftJoinCnt		INTEGER := 0;
	iLoopRightJoinCnt		INTEGER := 0;
	
	iLeftJoinLoopAliasCnt 	INTEGER := 0;
	iRightJoinLoopAliasCnt 	INTEGER := 0;
	
	tTablesSQL 				TEXT := pTableNames;
	  
	tSQL					TEXT;
	tLeftJoinLine			TEXT;
	tRightJoinLine			TEXT;
	tOrigLeftJoinLine 		TEXT;
	tOrigRightJoinLine 		TEXT;
	
	tLeftMatched			CHAR := 'N';
	
	tTableAliasReg 			TEXT := REPLACE(pTableAlias,'.','\.');	
	tTableAlias 			TEXT := pTableAlias;
	
	ls_table_name			TEXT;
	ls_column_name			TEXT;
	
	iStartPosition			INTEGER := 0;
	iEndPosition			INTEGER := 0;
	
	iLoopColNullableNoCnt	INTEGER := 0;
	
	iTabColExist			INTEGER := 0;
	iColNullableNo			INTEGER := 0;
	
	iLoopColNullableNo		INTEGER := 0;
	
	tLeftColumnAlias		TEXT;
	tRightColumnAlias 		TEXT;
	tOtherTableName 		TEXT;
	tOtherAlias				TEXT;
	tJoinConditions 		TEXT;
	tROWIDs					TEXT;
	tWhereClause 			TEXT;
	tWhereClauseCondition   TEXT;
	
	iAliasCnt 				INTEGER := 0;
	iAndCnt 				INTEGER := 0;
	iAliasLoopCnt 			INTEGER := 0;
	
	tLeftAliasColumnName	TEXT;
	tLeftAliasTableName		TEXT;
	tRightAliasColumnName	TEXT;
	tRightAliasTableName	TEXT;
	
	tTablesMarkerSQL		TEXT;
	
	rec						RECORD;

BEGIN

tTablesSQL := regexp_replace(tTablesSQL,'left join','LEFT JOIN','gi');
tTablesSQL := regexp_replace(tTablesSQL,'left outer join','LEFT JOIN','gi');
tTablesSQL := regexp_replace(tTablesSQL,'right join','RIGHT JOIN','gi');
tTablesSQL := regexp_replace(tTablesSQL,'right outer join','RIGHT JOIN','gi');
tTablesSQL := regexp_replace(tTablesSQL,' on ',' ON ','gi');
	  
SELECT count(1) INTO iLeftJoinCnt FROM regexp_matches(tTablesSQL,'LEFT JOIN','g');
SELECT count(1) INTO iRightJoinCnt FROM regexp_matches(tTablesSQL,'RIGHT JOIN','g');

tTablesSQL :=
		TRIM (
		   mv$regexpreplace(
			  tTablesSQL,
			  '([' || CHR (11) || CHR (13) || CHR (9) || ']+)',
			  ' '));

tTablesMarkerSQL :=	mv$regexpreplace(tTablesSQL, 'LEFT JOIN',pConst.COMMA_LEFT_TOKEN);
tTablesMarkerSQL :=	mv$regexpreplace(tTablesMarkerSQL, 'RIGHT JOIN',pConst.COMMA_RIGHT_TOKEN);
tTablesMarkerSQL :=	mv$regexpreplace(tTablesMarkerSQL, 'INNER JOIN',pConst.COMMA_INNER_TOKEN);
tTablesMarkerSQL :=	mv$regexpreplace(tTablesMarkerSQL, 'JOIN',pConst.COMMA_INNER_TOKEN);
tTablesMarkerSQL :=	mv$regexpreplace(tTablesMarkerSQL, ' ON ',pConst.ON_TOKEN);
			  
tSQL := tTablesSQL;

IF iLeftJoinCnt > 0 THEN
	  
	FOR i IN 1..iLeftJoinCnt
	LOOP
	
		tLeftJoinLine :=  'LEFT JOIN'||substr(substr(tTablesMarkerSQL,mv$regexpinstr(tTablesMarkerSQL, 
		'('|| pConst.COMMA_LEFT_TOKEN ||'+)',
			1,
			i,
			1,
			'i')),1,
				   mv$regexpinstr(substr(tTablesMarkerSQL,mv$regexpinstr(tTablesMarkerSQL,
		'('|| pConst.COMMA_LEFT_TOKEN ||'+)',
						   1,
			i,
			1,
			'i')),'('||pConst.COMMA_LEFT_TOKEN||'|'||pConst.COMMA_INNER_TOKEN||'|'||pConst.COMMA_RIGHT_TOKEN||')',
			1,
			1,
			1,
			'i')-3);
		
			--tOrigLeftJoinLine := tLeftJoinLine;
			
		IF tJoinTableInfoFound = 'N' THEN
			
			SELECT count(1) INTO iLeftJoinLoopAliasCnt FROM regexp_matches(tLeftJoinLine,tTableName||'+[[:space:]]+'||tTableAlias,'g');

			IF iLeftJoinLoopAliasCnt > 0 THEN
			
				/*tTableName := TRIM(REPLACE(substr(tLeftJoinLine,1,mv$regexpinstr(tLeftJoinLine,pConst.ON_TOKEN,
											1,
											1,
											1,
											'i')-3),tTableAlias,'')); */
				
				iStartPosition :=  mv$regexpinstr(tLeftJoinLine,pConst.ON_TOKEN,
					1,
					1,
					1,
					'i');
					
				tLeftJoinConditions := substr(tLeftJoinLine,iStartPosition);
				
				tLeftColumnAlias :=  TRIM(SUBSTR(tLeftJoinLine,
										   1,
											 mv$regexpinstr(tLeftJoinLine,
														   '(\.){1}',
														   1,
														   1)
										   - 1));

				tRightColumnAlias := TRIM(mv$regexpinstr(tLeftJoinLine, SUBSTR(tLeftJoinLine,1,
										mv$regexpinstr(tLeftJoinLine,
								  '[[:space:]]+(=|>|<|<>|!=)',
								  1,
								  1,
								  1,
								  'i')),'')); 
								  
				tRightColumnAlias := TRIM(SUBSTR(tRightColumnAlias,
										   1,
											 mv$regexpinstr(tRightColumnAlias,
														   '(\.){1}',
														   1,
														   1)
										   - 1));

				
				tJoinTableInfoFound := 'Y';
				
			END IF;
				
		ELSE
		
			IF tLeftColumnAlias = tTableAlias THEN
			
				SELECT count(1) INTO iLeftJoinLoopAliasCnt FROM regexp_matches(tLeftJoinLine,'[[:space:]]+'||tLeftColumnAlias,'g');
				
			ELSE
			
				SELECT count(1) INTO iLeftJoinLoopAliasCnt FROM regexp_matches(tLeftJoinLine,'[[:space:]]+'||tRightColumnAlias,'g');
				
			END IF;

			IF iLeftJoinLoopAliasCnt > 0 THEN
			
				tOtherTableName := TRIM(REPLACE(substr(tLeftJoinLine,1,mv$regexpinstr(tLeftJoinLine,pConst.ON_TOKEN,
											1,
											1,
											1,
											'i')-3),tRightColumnAlias,''));
											
				tOtherTableFound := 'Y';
		
			END IF;
			
		END IF;

	END LOOP;

ELSIF iRightJoinCnt > 0 THEN

	--iLoopColNullableNoCnt := 0;

	FOR i IN 1..iRightJoinCnt
	LOOP
		
		tRightJoinLine :=  'RIGHT JOIN'||substr(substr(tTablesMarkerSQL,mv$regexpinstr(tTablesMarkerSQL, 
		'('|| pConst.COMMA_RIGHT_TOKEN ||'+)',
			1,
			i,
			1,
			'i')),1,
				   mv$regexpinstr(substr(tTablesMarkerSQL,mv$regexpinstr(tTablesMarkerSQL,
		'('|| pConst.COMMA_RIGHT_TOKEN ||'+)',
						   1,
			i,
			1,
			'i')),'('||pConst.COMMA_LEFT_TOKEN||'|'||pConst.COMMA_INNER_TOKEN||'|'||pConst.COMMA_RIGHT_TOKEN||')',
			1,
			1,
			1,
			'i')-3);
		
			--tOrigRightJoinLine := tRightJoinLine;
			
		SELECT count(1) INTO iRightJoinLoopAliasCnt 
		FROM regexp_matches(tRightJoinLine,'[[:space:]]+'||tTableAlias,'g');

		IF tJoinTableInfoFound = 'N' THEN

			IF iRightJoinLoopAliasCnt > 0 THEN
			
				iStartPosition :=  mv$regexpinstr(tRightJoinLine,pConst.ON_TOKEN,
						1,
						1,
						1,
						'i');
						
				tRightJoinConditions := substr(tRightJoinLine,iStartPosition);
				
				tLeftColumnAlias :=  TRIM(SUBSTR(tRightJoinLine,
										   1,
											 mv$regexpinstr(tRightJoinLine,
														   '(\.){1}',
														   1,
														   1)
										   - 1));

				tRightColumnAlias := TRIM(mv$regexpinstr(tRightJoinLine, SUBSTR(tRightJoinLine,1,
										mv$regexpinstr(tRightJoinLine,
								  '[[:space:]]+(=|>|<|<>|!=)',
								  1,
								  1,
								  1,
								  'i')),'')); 
								  
				tRightColumnAlias := TRIM(SUBSTR(tRightColumnAlias,
										   1,
											 mv$regexpinstr(tRightColumnAlias,
														   '(\.){1}',
														   1,
														   1)
										   - 1));

				
				tJoinTableInfoFound := 'Y';
				
			END IF;
				
		ELSE
		
			IF tOtherTableFound = 'N' THEN
		
				IF tLeftColumnAlias = tTableAlias THEN
				
					SELECT count(1) INTO iLeftJoinLoopAliasCnt FROM regexp_matches(tLeftJoinLine,'[[:space:]]+'||tLeftColumnAlias,'g');
					
				ELSE
				
					SELECT count(1) INTO iLeftJoinLoopAliasCnt FROM regexp_matches(tLeftJoinLine,'[[:space:]]+'||tRightColumnAlias,'g');
					
				END IF;

				IF iLeftJoinLoopAliasCnt > 0 THEN
				
					tOtherTableName := TRIM(REPLACE(substr(tLeftJoinLine,1,mv$regexpinstr(tLeftJoinLine,pConst.ON_TOKEN,
												1,
												1,
												1,
												'i')-3),tRightColumnAlias,''));
												
					tOtherTableFound := 'Y';
			
				END IF;
				
			END IF;
			
		END IF;
		
	END LOOP;

END IF;

IF pTableAlias = tLeftColumnAlias THEN
	tOtherAlias := tLeftColumnAlias;
	tJoinConditions := COALESCE(tLeftJoinConditions,tRightJoinConditions);
	
ELSE
	tOtherAlias := tRightColumnAlias;
	tJoinConditions := COALESCE(tLeftJoinConditions,tRightJoinConditions);
END IF;

tJoinConditions := REPLACE(tJoinConditions,pTableAlias,'src$');
tJoinConditions := REPLACE(tJoinConditions,tOtherAlias,'src$99');

FOR rec IN (SELECT UNNEST(pRowidArray) rowid) LOOP

	tROWIDs := tROWIDs||x.rowid||',';
	
END LOOP;

SELECT count(1) INTO iAliasCnt FROM regexp_matches(pWhereClause,pTableAlias,'g');

IF iAliasCnt > 0 THEN

tWhereClause := REPLACE(pWhereClause, chr(9), chr(32) );
tWhereClause := REPLACE(tWhereClause, ' and ', ' AND ' );
tWhereClause := REPLACE(tWhereClause, ' AND  ', ' ### ' );

SELECT count(1) INTO iAndCnt FROM regexp_matches(tWhereClause,' AND ','g');	

iAndCnt := iAndCnt + 1;

FOR i IN 1..iAndCnt LOOP

iAliasLoopCnt := iAliasLoopCnt + 1;

IF iAliasLoopCnt = 1 THEN

	tWhereClauseCondition := REPLACE(SUBSTR(tWhereClause,1,mv$regexpinstr(tWhereClause,'###',
						1,
						1,
						1,
						'i')-4),'WHERE ','');
						
END IF;

END LOOP;
	
tROWIDs := SUBSTR(tROWIDs,1,length(tROWIDs)-1);

tSQL := 'DELETE FROM '||pViewnName||'
	  WHERE ctid IN ( SELECT 
							ctid
					  FROM
						  (SELECT ctid,
								  ROW_NUMBER() OVER(
                        PARTITION BY '||tROWIDs||'
						ORDER BY '||pTableAlias||'_m_row$ NULLS FIRST
						) r,
						COUNT(*) OVER(
						PARTITION BY '||tROWIDs||'
						) t_cnt,
						COUNT('||pTableAlias||'_m_row$) OVER(
						PARTITION BY '||tROWIDs||'
						) nonnull_cnt
						FROM
							'||pViewName||' mv$1
						WHERE
							'||tOtherAlias||'_m_row$ IN (
								SELECT src$99.m_row$
								FROM
									(
										SELECT sna$.m_row$ rid$,
											   sna$.*
										FROM
											'||tTableName||' sna$
										WHERE
											m_row$ IN (SELECT unnest(pRowIDArray))
									) src$,
								'||tOtherTableName||' src$99
								WHERE '||tJoinConditions||'
							)
						) mv$1
					WHERE
					t_cnt >= 1
					AND ( ( nonnull_cnt = 0
							AND r >= 1 )
							OR ( nonnull_cnt > 0
							   AND r <= t_cnt - nonnull_cnt ) )';


RETURN tSQL;

END;
$BODY$
LANGUAGE    plpgsql;